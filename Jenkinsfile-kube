pipeline 
{
    agent any
    
    triggers 
    {
        pollSCM('*/1 * * * *')
    }

    environment
    {
        WINDOWSIP="192.168.56.1"
        GIT_SSH_COMMAND = "ssh -o StrictHostKeyChecking=no" 
        GITURL="git@github.com:oksthefox/flask.git"
        ANSIBLEFOLDER="/var/lib/jenkins/AnsibleFiles/Ansible-JenkinsFiles"
    }


    stages 
    {


        stage('Docker Login') 
        {
            steps 
            {
                // Use the "withCredentials" block to securely access Docker credentials
                withCredentials([usernamePassword(credentialsId: 'DockerLogin', usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
                    // Replace 'your-docker-registry' with your Docker registry URL (e.g., Docker Hub)
                    sh "docker login -u ${DOCKER_USERNAME} -p ${DOCKER_PASSWORD}"
                }
            }
        }

        stage('start proxy')
        {
            steps
            {
                script
                {
                    echo "open a terminal where it running proxy command in the backround..."
                    sh '''
                        nohup ssh -o StrictHostKeyChecking=no user@192.168.56.1 "kubectl proxy --address=0.0.0.0 --port=8080 --accept-hosts=.*" &
                    '''
                    
                }
            }
        }
        stage('Changes Check') 
        {
            steps 
            {
                script 
                {
                    changeCheck("Jenkinsfile-kube")
                }
            }
        }

        stage('Cleanup') 
        {
            when 
            {
                expression 
                {
                    return env.RELEVANT_CHANGES != "false"
                }
            }
            steps 
            {
                //Removes Unnecessary files
                echo 'Performing cleanup...'
                sh 'rm -rf *'
                sh "docker image prune -f"
                sh "docker images | grep -w 'oksthefox/dockerflask' | grep -w 1\\.[0-9]* | awk '{print \$2}' | xargs -I {} docker rmi oksthefox/dockerflask:{}"
                sh "docker images | grep -w 'oksthefox/dockerdb' | grep -w 1\\.[0-9]* | awk '{print \$2}' | xargs -I {} docker rmi oksthefox/dockerdb:{}"
            }
        }
        
        stage('Build') 
        {

            when {
                expression {
                    return env.RELEVANT_CHANGES != "false"
                }
            }
            steps
            {
                //clonning from github to workspace
                echo 'Cloning repository...'
                sh "git clone $env.GITURL"
                script
                {
                    packageHelmChart("./flask","my-terrform-state-oksana-flask-project","helm-packages")
                }
                sh 'ls'
            }
        }

        stage('Prepare GKE Cluster') 
        {
            steps 
            {
                script 
                {
                    // Change the current working directory to where your Terraform files are
                    dir('./flask/TerraformFiles') 
                    {
                        // Initialize Terraform
                        sh 'terraform init'
                        sh 'terraform apply -auto-approve'
                        echo 'Updating kubectl context...'
                        sh 'gcloud container clusters get-credentials cluster-flask2 --zone europe-north1-a --project ultra-palisade-393305'
                    }
                }
            }
        }

        stage('Install Systen Level Dependencies')
        {
            when{
                expression{
                    return env.RELEVANT_CHANGES !="false"
                }
            }
            steps
            {
                script
                {
                    sh "ansible-playbook /var/lib/jenkins/AnsibleFiles/Ansible-JenkinsFiles/installLocal.yml"
                    sh "pip install -r ./flask/flask-app/requirements.txt"
                }
            }
        }

        stage('Build-create docker image and push') 
        {
            when {
                expression 
                {
                    return env.RELEVANT_CHANGES != "false"
                }
            }
            steps 
            {
                dir('./flask/flask-app/') 
                {
                    // Stage building
                    echo 'Building flask'
                    sh "docker build -t oksthefox/dockerflask:1.${BUILD_NUMBER} -t oksthefox/dockerflask:latest ."
                    sh "docker push --all-tags oksthefox/dockerflask"
                }
            }
        }
        
        stage('Build-create docker DB image and push') 
        {
            when 
            {
                expression 
                {
                    return env.RELEVANT_CHANGES != "false"
                }
            }
            steps 
            {
                dir('./flask/mysql/')
                {
                    echo 'building db'
                    sh "docker build -t oksthefox/dockerdb:1.${BUILD_NUMBER} -t oksthefox/dockerdb:latest ."
                    sh "docker push --all-tags oksthefox/dockerdb"
                }
            }
        }
        
        stage('Deploy for testing') 
        {
            when 
            {
                expression 
                {
                    return env.RELEVANT_CHANGES != "false"
                }
            }
            steps 
            {
                script
                {
                    echo 'Making Sure im in right context...'
                    sh "kubectl config use-context docker-desktop"
                    echo "deploying application"

                    echo "fetching the chart package name..."
                    def latestchart=sh(script: "ls ./flask/myproject*.tgz | sort -V | tail -n 1", returnStdout: true).trim()

                    echo "picking name for helm"
                    def releasename= "flask-release"

                    echo "Deployment..."
                    sh "helm upgrade --install ${releasename} ${latestchart}"

                    def tcpport=sh(script: "kubectl get service flask-service-testing -o=jsonpath='{.spec.ports[*].nodePort}'", returnStdout: true).trim()
                    env.KUBECTLTCPPORT=tcpport
                    echo "TCP port is ${env.KUBECTLTCPPORT}"
                }

            }
        }

        stage('Rollout Restart Test') 
        {
            when 
            {
                expression 
                {
                    return env.RELEVANT_CHANGES != "false"
                }
            }
            steps 
            {
                echo 'Performing rollout restart...'
                sh "kubectl rollout restart deployment/flask-deployment"
                sh "kubectl rollout restart deployment/mysql-deployment"
            }
        }

        stage('Test testing enviornment (d4d)')
        {
            when 
            {
                expression 
                {
                    return env.RELEVANT_CHANGES != "false"
                }
            }
            steps
            {
                script
                {
                    try 
                    {
                        retry(30)
                        {
                            sh "sleep 10"
                            sh "curl http://${env.WINDOWSIP}:${env.KUBECTLTCPPORT}"
                        }
                    } 
                    catch (Exception e) 
                    {
                        echo "Test Failed"
                        currentBuild.result = 'FAILURE'
                        error "Test Failed"
                    }
                }

            }
        }

        
        stage('closing testing enviroment')
        {
            when 
            {
                expression 
                {
                    return env.RELEVANT_CHANGES != "false"
                }
            }
            steps
            {
                script
                {
                    echo "closing test enviroment..."
                    sh "helm uninstall flask-release"
                }
            }
        }

        stage('deploying on google k8s production')
        {
            when 
            {
                expression 
                {
                    return env.RELEVANT_CHANGES != "false"
                }
            }
            steps
            {
                script
                {
                    echo "deploying on google k8s production..."
                    sh "kubectl config use-context gke_ultra-palisade-393305_me-west1-a_cluster-flask2"
                    
                    echo "fetching the chart package name..."
                    def latestchart=sh(script: "ls ./flask/myproject*.tgz | sort -V | tail -n 1", returnStdout: true).trim()

                    echo "picking name for helm"
                    def releasename= "flask-release"

                    echo "Deployment..."
                    sh "helm upgrade --install ${releasename} ${latestchart}"

                }
            }

        }

        stage('Rollout Restart K8s') 
        {
            when 
            {
                expression 
                {
                    return env.RELEVANT_CHANGES != "false"
                }
            }
            steps 
            {
                echo 'Performing rollout restart...'
                sh "kubectl rollout restart deployment/flask-deployment"
                sh "kubectl rollout restart deployment/mysql-deployment"
                sh "kubectl get all"
            }
        }

        stage('closing proxy')
        {
            when 
            {
                expression 
                {
                    return env.RELEVANT_CHANGES != "false"
                }
            }
            steps
            {
                script
                {
                    sh '''
                        ssh -o StrictHostKeyChecking=no user@192.168.56.1 "taskkill /F /IM kubectl.exe"
                    '''
                }
            }
        }

    }
}


def changeCheck (String jenkinsfile)
{
    def changeSets = currentBuild.changeSets
    if(changeSets.size()==0)
    {
        echo "no changes, ran manually proceeding"
        env.RELEVANT_CHANGES = "true"
    }
    else
    {
        def modifiedFiles = []
        for(changeSet in changeSets) 
        {
            for(item in changeSet) 
            {
                modifiedFiles += item.getAffectedPaths()
            }
        }
        modifiedFiles = modifiedFiles.minus("$jenkinsfile")
        if (modifiedFiles.isEmpty()) 
        {
            println('Skipping pipeline execution as the only change is to the Jenkinsfile.')
            env.RELEVANT_CHANGES = "false"
        }
        else
        {
            env.RELEVANT_CHANGES = "true"
        }
    }

}



def packageHelmChart(String folder, String bucket, String bucketFolder) {
    // Check for changes in the mynewchart directory
    def chartChanges = sh(script: "git diff --name-only HEAD~1 HEAD | grep mychart || true", returnStdout: true).trim()

    // Fetch latest chart from GCS
    def latestChart = sh(script: "gsutil ls gs://${bucket}/${bucketFolder}/myproject*.tgz | sort -V | tail -n 1", returnStdout: true).trim()

    sh "gsutil cp ${latestChart} ${folder}/"

    if (chartChanges) {
        // Unpack the chart
        sh "mkdir -p ${folder}/unpackedChart"
        sh "tar -xzvf ${folder}/myproject*.tgz -C ${folder}/unpackedChart"

        // Copy changes from static mynewchart to the unpacked version, excluding Chart.yaml
        sh "rsync -av --exclude='Chart.yaml' ${folder}/mychart/ ${folder}/unpackedChart/myproject/"

        // Determine the type of change
        def changeType = 'patch'  // default to patch

        if (chartChanges.contains("Chart.yaml")) {
            changeType = 'major'
        } else if (chartChanges.contains("templates/")) {
            changeType = 'minor'
        }

        // Bump the version
        sh "bash ${folder}/scripts/versionBump.sh ${changeType} ${folder}/unpackedChart/myproject/Chart.yaml"

        // Extract the new version from Chart.yaml using awk
        def newVersion = sh(script: "awk '/name: myproject/{getline; print \$2}' ${folder}/unpackedChart/myproject/Chart.yaml", returnStdout: true).trim()

        // Predict the packaged chart name
        def packagedChartName = "myproject-${newVersion}.tgz"

        // Repackage the chart
        sh "helm package ${folder}/unpackedChart/myproject -d ${folder}"

        // Upload the repackaged chart to GCS
        sh "gsutil cp ${folder}/${packagedChartName} gs://${bucket}/${bucketFolder}/"

        // Cleanup
        sh "rm -rf ${folder}/unpackedChart"
    }
}